/* File: libxarc/xarc_impl.h
 * XARC module interface.
 */

/* Copyright 2013 John Eubank.

   This file is part of XARC.

   XARC is free software: you can redistribute it and/or modify it under the
   terms of the GNU Lesser General Public License as published by the Free
   Software Foundation, either version 3 of the License, or (at your option)
   any later version.

   XARC is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with XARC.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef XARC_IMPL_H_INC
#define XARC_IMPL_H_INC

#ifdef __cplusplus
extern "C" {
#endif


#include <stdio.h>
#include <stddef.h>
#include <xarc.h>


/* Section: Types */

struct _handler_funcs;

/* Struct: xarc_error
 * Details of an error that has occurred in XARC or one of its component
 * libraries.
 */
typedef struct
{
	/* Field: xarc_id
	 * The xarc error identifier (see <XARC result codes>).
	 */
	xarc_result_t xarc_id;
	/* Field: library_error_id
	 * If the most recent xarc operation generated an XARC_MODULE_ERROR, an
	 * XARC_DECOMPRESS_ERROR, or an XARC_FILESYSTEM_ERROR, contains the error
	 * code generated by the library in question. For XARC_FILESYSTEM_ERROR,
	 * this will be the value of the standard library's errnum. If none of the
	 * above errors have occurred, will be 0.
	 */
	int32_t library_error_id;
	/* Field: error_additional
	 * Any additional descriptive text attached to the error, such as actions
	 * being performed and the names of files being processed; or the empty
	 * string ("") if no additional text was generated.
	 */
	xchar* error_additional;
} xarc_error;

/* Struct: _xarc
 * The actual implementation of the opaque <xarc> object.
 */
struct _xarc
{
	/* Field: impl
	 * The module-specific implementation functions for the type of archive that
	 * was opened (see <handler_funcs>).
	 */
	const struct _handler_funcs* impl;
	/* Field: error
	 * The details of any error that has occurred for this <xarc> object. If
	 * NULL, no error has occurred yet.
	 */
	xarc_error* error;
};

/* Struct: handler_funcs
 * Module-specific implementation functions for a given archive type.
 */
typedef struct _handler_funcs
{
	/* Function: close
	 * Close the archive.
	 *
	 * This function must free any memory allocated by the module (which
	 * is probably pointed to in the extended portion of the object), but should
	 * not free the <xarc> object itself or any memory not allocated in the
	 * module. It should also close any open files, and generally do anything
	 * else necessary to release held resources.
	 *
	 * Parameters:
	 *   x - The <xarc> object to be closed
	 *
	 * Returns:
	 *   XARC_OK - If the module successfully closed the archive
	 *   <xarc_result_t> - Any error that occurred (see <XARC result codes>)
	 */
	xarc_result_t (*close)(xarc* x);
	/* Function: next_item
	 * Seek to the next archive entry.
	 *
	 * If the archive is already at its last entry, must set & return
	 * XARC_NO_MORE_ITEMS.
	 *
	 * Parameters:
	 *   x - The <xarc> object
	 *
	 * Returns:
	 *   XARC_OK - If the module successfully closed the archive
	 *   XARC_NO_MORE_ITEMS - If the archive is already at the last entry
	 *   <xarc_result_t> - Any error that occurred (see <XARC result codes>)
	 */
	xarc_result_t (*next_item)(xarc* x);
	/* Function: item_get_info
	 * Retrieve the current entry's metadata.
	 *
	 * This function must fill out the user-provided <xarc_item_info> struct.
	 * Memory for all strings or other pointers within <xarc_item_info> must be
	 * allocated from the heap _by the module_, and freed either on the next
	 * call to <next_item>, or when the archive is closed.
	 *
	 * Parameters:
	 *   x - The <xarc> object
	 *   info - Pointer to a user-provided <xarc_item_info> object to be filled
	 *     out with the metadata
	 *
	 * Returns:
	 *   XARC_OK - If the metadata was successfully retrieved
	 *   <xarc_result_t> - Any error that occurred (see <XARC result codes>)
	 */
	xarc_result_t (*item_get_info)(xarc* x, xarc_item_info* info);
	/* Function: item_extract
	 * Extract the current entry to an open file.
	 *
	 * This function will only be called for entries that are actual files, not
	 * directories (or symlinks, etc.). The module must update the "written"
	 * parameter to reflect the number of bytes written into the file stream.
	 *
	 * Parameters:
	 *   x - The <xarc> object
	 *   to - An already-opened file to stream the data to
	 *   written - Pointer to a size_t that must be set to the number of bytes
	 *     written into the file stream
	 *
	 * Returns:
	 *   XARC_OK - If the entry was successfully extracted
	 *   <xarc_result_t> - Any error that occurred (see <XARC result codes>)
	 */
	xarc_result_t (*item_extract)(xarc* x, FILE* to, size_t* written);
	/* Function: item_set_props
	 * After extraction, apply metadata for the current item in the filesystem.
	 *
	 * This function must apply as much of the current entry's metadata as
	 * possible (given the host platform's support/limitations) to the specified
	 * filesystem path.
	 *
	 * Parameters:
	 *   x - The <xarc> object
	 *   path - The filesystem path to apply metadata to
	 *
	 * Returns:
	 *   XARC_OK - If all possible metadata was successfully applied
	 *   <xarc_result_t> - Any error that occurred (see <XARC result codes>)
	 */
	xarc_result_t (*item_set_props)(xarc* x, const xchar* path);
	/* Function: error_description
	 * Convert an error ID into a user-friendly error string.
	 *
	 * Given an error ID stemming from the module's own code or libraries,
	 * this function must return a user-friendly descriptive string of the error
	 * type. Ideally, the string should be a compile-time constant. If
	 * that is unfeasible, memory for the string must be allocated on the heap
	 * and freed the next time this function is called or when the <xarc> object
	 * is closed. If the error ID is for some reason outside the range generated
	 * by the module or library, a string indicating that the error type is
	 * undefined should be returned.
	 *
	 * Parameters:
	 *   x - The <xarc> object
	 *   error_id - The integer error ID to translate
	 *
	 * Returns:
	 *   A string describing the error type indicated by the supplied ID
	 */
	const xchar* (*error_description)(xarc* x, int32_t error_id);
} handler_funcs;


/* Section: Global Functions */

/* Function: xarc_set_error
 * Place the <xarc> object in an errored state with the supplied error data.
 *
 * Every module function should always call this function (or
 * <xarc_set_error_filesys>) before returning anything besides XARC_OK, unless a
 * subordinate function has already done so. An easy way to do this is to use
 * <xarc_set_error> in the return statement:
 * |	if (GOOD_RESULT != my_result)
 * |	{
 * |		return xarc_set_error(x, XARC_MODULE_ERROR, my_result,
 * |	 	 XC("mymodule had a bad result!"));
 * |	}
 *
 * Parameters:
 *   x - The <xarc> object
 *   status - The XARC result code to apply and return (see <XARC result codes>)
 *   library_error_id - The error ID specific to this module or a library it
 *     uses, if any. ("0" is an acceptable indicator of no library-specific ID.)
 *   addl_fmt - A printf-style format string containing any situation-specific
 *     information to be reported, such as file names or other entry data.
 *   ... - Format arguments as required by addl_fmt
 *
 * Returns:
 *   The same result code supplied in the "status" argument (see <XARC result
 *   codes>)
 */
xarc_result_t xarc_set_error(xarc* x, xarc_result_t status,
 int32_t library_error_id, const xchar* addl_fmt, ...);
/* Function: xarc_set_error_filesys
 * Place the <xarc> object in an errored state using XARC_FILESYSTEM_ERROR as
 * the XARC result code, the value of *errno* as the library-specific error
 * code, and any additional supplied error information.
 *
 * Parameters:
 *   x - The <xarc> object
 *   addl_fmt - A printf-style format string containing any situation-specific
 *     information to be reported, such as file names or other entry data.
 *   ... - Format arguments as required by addl_fmt
 *
 * Returns:
 *   XARC_FILESYSTEM_ERROR (see <XARC result codes>)
 */
xarc_result_t xarc_set_error_filesys(xarc* x, const xchar* addl_fmt, ...);


/* Section: Macros */

/* Macro: X_BASE(x)
 * Cast pointer "x" into a pointer to the base portion of the <xarc> object, as
 * defined in struct <_xarc>.
 */
#define X_BASE(x) ((struct _xarc*)x)

#ifndef XCONCAT2
#define INNER_CONCAT2(a, b) a ## b
#define XCONCAT2(a, b) INNER_CONCAT2(a, b)
#endif

/* Macro: XARC_DEFINE_MODULE(name, open_func, extra_size)
 * Create a registry handle for a module.
 *
 * A module's source code will typically call this macro once, to create the
 * required linkage with its registration in <libxarc/modules.inc>.
 *
 * The "open_func" argument must be a function pointer matching the following
 * signature:
 * |	xarc_result_t (*)(xarc* x, const xchar* file, uint8_t type);
 * In addition to whatever is necessary to open the archive file, this
 * "open_func" must do the following things:
 *  - Initialize the memory allocated immediately after the base (struct
 *      <_xarc>) portion of the object, per the extra_size argument of the
 *      macro.
 *  - Initialize the "impl" member of the base object to point to a
 *      <handler_funcs> object holding the rest of the module's implementation
 *      functions.
 *
 * Arguments:
 *   name - Simple identifier (must follow C/C++ identifier lexical rules)
 *     naming the module
 *   open_func - Archive file "opener" function
 *   extra_size - Amount of extra memory (in bytes) to allocate for module-
 *     specific implementation
 *
 * Example:
 * |	typedef struct
 * |	{
 * |		stuff* state_thingy;
 * |	} m_mymod_extra;
 * |
 * |	handler_funcs mymod_funcs = {
 * |		m_mymod_close,
 * |		m_mymod_next_item,
 * |		m_mymod_item_get_info,
 * |		m_mymod_item_extract,
 * |		m_mymod_item_set_props,
 * |		m_mymod_error_description
 * |	};
 * |
 * |	#define M_MYMOD(x) ((m_mymod_extra*)((void*)x + sizeof(struct _xarc)))
 * |
 * |	xarc_result_t m_mymod_open(xarc* x, const xchar* file, uint8_t type)
 * |	{
 * |		memset(M_MYMOD(x), 0, sizeof(m_mymod_extra));
 * |		X_BASE(x)->impl = &mymod_funcs;
 * |		M_MYMOD(x)->state_thingy = try_to_open_my_archive(file);
 * |		if (!M_MYMOD(x)->state_thingy)
 * |		{
 * |			return xarc_set_error(x, XARC_ERR_NOT_VALID_ARCHIVE, 0,
 * |			 XC("Failed to open '%s'! Oh horror!"), file);
 * |		}
 * |		return XARC_OK;
 * |	}
 * |
 * |	XARC_DEFINE_MODULE(mod_mymod, m_mymod_open, sizeof(m_mymod_extra))
 */
#define XARC_DEFINE_MODULE(name, open_func, extra_size) \
 const size_t XCONCAT2(xarc_extra_size_, name) = extra_size; \
 xarc_result_t (*XCONCAT2(xarc_open_func_, name)) \
 (xarc*, const xchar*, uint8_t) \
  = open_func;


#ifdef __cplusplus
} // extern "C"
#endif

#endif // XARC_IMPL_H_INC
